/**************************************************************************************************/
/*
 *  Circuit printing
 *  by Gabriel Luca Nazar <glnazar@inf.ufrgs.br>
 *
 */
/**************************************************************************************************/

#include "XDWCCOut.h"

using namespace std;

/**************************************************************************************************/
//checks if a signal is a part of a vector
bool XDWCCOut::isVector(Net* netptr){
	
	return netptr->name[netptr->name.size()-1] == ')';
}

/**************************************************************************************************/
//builds a signal vector for printing
void XDWCCOut::buildSignalVec(vector<Net*> &nets, unsigned *high, unsigned *low, char* buf, vector<bool> &printed, unsigned id){
	unsigned int id2, pos;
	unsigned nameLength;
	
	sscanf(nets[id]->name.c_str(), "%[^(]s", buf);
	nameLength = strlen(buf);
	sscanf(nets[id]->name.c_str()+nameLength, "(%d)", low);
	printed[id] = true;
	
	id2 = id+1;
	while(id2 < nets.size()){
		if(nets[id2]->name.find(buf) != -1 && nets[id2]->name.find('(') == nameLength){
			printed[id2] = true;
			id2++;
		} else
			break;		
	}
	*high = *low + id2 - (id+1);	
	
}

/**************************************************************************************************/
//prints the output file
void XDWCCOut::printOutput(Circuit* circIn, const char* filename){
	FILE* outfile;
	int i, j, k;
	char buf[BUFSIZE], buf2[BUFSIZE]; //auxiliary buffers for variable names
	vector<bool> printedNets; //if a net was already printed
	unsigned high, low; //high and low ends of a signal vector
	Lut* newLut; //pointer to newly instantiated luts
	vector<string> POsNames, POsTypes;
	vector<string> PIsNames, PIsTypes;
	vector<int> PIsVecSize;
	string newPName;
	Circuit* circ = circIn;
	unsigned errorsCnt = ceil(((double) circ->POs.size()) / 3.0);
	
	if(options[OPT_ERROR_PO_SAMEW]){
		errorsCnt = circ->POs.size();
	}

	cout << "Printing output file: " << filename << endl;
	
	outfile = fopen(filename, "w");
	
	fprintf(outfile, "----------------------------------------------------------------------------------\n");
	fprintf(outfile, "--Fault tolerant version of %s\n", circ->name.c_str());
	fprintf(outfile, "--Generated by ftXil, by Gabriel Luca Nazar\n");
	fprintf(outfile, "----------------------------------------------------------------------------------\n");
	
	fprintf(outfile, "\nlibrary IEEE;\n");
	fprintf(outfile, "use IEEE.STD_LOGIC_1164.ALL;\n");
	fprintf(outfile, "library UNISIM;\n");
	fprintf(outfile, "use UNISIM.VCOMPONENTS.ALL;\n");
	
	//Entity declaration************************************************************
	if(options[OPT_E_AGGREG])
		fprintf(outfile, "entity %s_ft_ea is\n", circ->name.c_str());
	else
		fprintf(outfile, "entity %s_ft is\n", circ->name.c_str());
	fprintf(outfile, "\tport (\n");
	
	//initializes printedNets
	printedNets.resize(circ->nets.size());
	for(i=0; i<printedNets.size(); i++)
		printedNets[i] = false;
	
	//prints primary inputs
	PIsNames.clear();
	PIsVecSize.clear();
	PIsTypes.clear();
	for(i=0; i<circ->PIs.size(); i++)
		if(!printedNets[circ->PIs[i]->id]){
			if(isVector(circ->PIs[i])){
				buildSignalVec(circ->nets, &high, &low, buf, printedNets, circ->PIs[i]->id);
				fprintf(outfile, "\t\t%s : in STD_LOGIC_VECTOR(%d downto %d);\n", buf, high, low);
				
				newPName.assign(buf);
				PIsNames.push_back(newPName);
				
				snprintf(buf2, BUFSIZE, "STD_LOGIC_VECTOR(%d downto %d)", high, low);
				newPName.assign(buf2);
				PIsTypes.push_back(newPName);
				PIsVecSize.push_back((high - low) + 1);
			} else {
				fprintf(outfile, "\t\t%s : in STD_LOGIC;\n", circ->PIs[i]->name.c_str());
				printedNets[circ->PIs[i]->id] = true;
				
				PIsNames.push_back(circ->PIs[i]->name.c_str());
				
				newPName.assign("STD_LOGIC");
				PIsTypes.push_back(newPName);
				PIsVecSize.push_back(1);				
			}
		}
		
	if(options[OPT_DUPLICATE_PI]){
		fprintf(outfile, "\t\tinputs_copy : in STD_LOGIC_VECTOR ( %ld downto 0 );\n", circ->PIs.size()-1);
	}
	
	//POs names must be stored to print the internal PO signals, that are required for checking.
	POsNames.clear();
	for(i=0; i<circ->POs.size(); i++){
		if(!printedNets[circ->POs[i]->id])
			if(isVector(circ->POs[i])){
				buildSignalVec(circ->nets, &high, &low, buf, printedNets, circ->POs[i]->id);
				fprintf(outfile, "\t\t%s : out STD_LOGIC_VECTOR(%d downto %d);\n", buf, high, low);
				
				newPName.assign(buf);
				POsNames.push_back(newPName);
				
				snprintf(buf2, BUFSIZE, "STD_LOGIC_VECTOR(%d downto %d)", high, low);
				newPName.assign(buf2);
				POsTypes.push_back(newPName);
			} else {
				fprintf(outfile, "\t\t%s : out STD_LOGIC;\n", circ->POs[i]->name.c_str());
				printedNets[circ->POs[i]->id] = true;
				
				POsNames.push_back(circ->POs[i]->name.c_str());
				
				newPName.assign("STD_LOGIC");
				POsTypes.push_back(newPName);
			}
		}
	
	if(options[OPT_2RAIL]){
		if(options[OPT_E_AGGREG]) {
			if( options[OPT_ERROR_PO_SAMEW] )
				fprintf(outfile, "\t\terrorVecPO : out STD_LOGIC_VECTOR(%d downto 0);\n", errorsCnt);
			else
				fprintf(outfile, "\t\terrorDetectedPO : out STD_LOGIC;\n");
		} else
			fprintf(outfile, "\t\terrorVecPO : out STD_LOGIC_VECTOR(%d downto 0);\n", errorsCnt-1);

	}

	if(options[OPT_E_AGGREG]){
		if( options[OPT_ERROR_PO_SAMEW] )
			fprintf(outfile, "\t\terrorVec : out STD_LOGIC_VECTOR(%d downto 0)\n", errorsCnt);
		else
			fprintf(outfile, "\t\terrorDetected : out STD_LOGIC\n");
	} else
		fprintf(outfile, "\t\terrorVec : out STD_LOGIC_VECTOR(%d downto 0)\n", errorsCnt-1);
	
	if(options[OPT_E_AGGREG]){
		fprintf(outfile, "\t);\nend %s_ft_ea;\n\n", circ->name.c_str());
		fprintf(outfile, "architecture Structure of %s_ft_ea is\n\n", circ->name.c_str());
	} else {
		fprintf(outfile, "\t);\nend %s_ft;\n\n", circ->name.c_str());
		fprintf(outfile, "architecture Structure of %s_ft is\n\n", circ->name.c_str());
	}
	
	//Signals & Components declaration************************************************************
	//error aggregation component
	if(errorsCnt > 1 && options[OPT_E_AGGREG]) {
		fprintf(outfile, "\tcomponent multiple_input_or is\n");
		fprintf(outfile, "\t\tGeneric (\n");
		fprintf(outfile, "\t\t\tGATE_INPUT_SIZE : integer := %d;\n", errorsCnt);
		fprintf(outfile, "\t\t\tLOG_GATE_INPUT_SIZE : integer := %d);\n", (int) ceil(log(errorsCnt)/log(2)));
		fprintf(outfile, "\t\tPort ( input_vec : in  STD_LOGIC_VECTOR(GATE_INPUT_SIZE-1 downto 0);\n");
		fprintf(outfile, "\t\t\toutput : out  STD_LOGIC);\n");
		fprintf(outfile, "\tend component;\n");
	}
	
	if(!options[OPT_NO_CMP_MODULE]){
		fprintf(outfile, "\tcomponent comparator is\n");
		if(options[OPT_ERROR_PO_SAMEW])
			fprintf(outfile, "\t\tGeneric ( IN_WIDTH : integer := %ld;\n", options[OPT_2RAIL] ? 2*errorsCnt : circ->POs.size());
		else
			fprintf(outfile, "\t\tGeneric ( IN_WIDTH : integer := %ld;\n", options[OPT_2RAIL] ? 6*errorsCnt : circ->POs.size());
		fprintf(outfile, "\t\t\tOUT_WIDTH : integer := %d\n", options[OPT_2RAIL] ? 2*errorsCnt: errorsCnt);
		fprintf(outfile, "\t\t);\n");
		fprintf(outfile, "\tPort ( inVecA : in  STD_LOGIC_VECTOR (IN_WIDTH-1 downto 0);\n");
		fprintf(outfile, "\t\tinVecB : in  STD_LOGIC_VECTOR (IN_WIDTH-1 downto 0);\n");
		fprintf(outfile, "\t\terrors : out  STD_LOGIC_VECTOR (OUT_WIDTH-1 downto 0));\n");
		fprintf(outfile, "\tend component;\n");
	}
	
	if(!options[OPT_NO_CMP_MODULE]){
		if(options[OPT_ERROR_PO_SAMEW])
			fprintf(outfile, "\tsignal c0_cmp_outvec, c1_cmp_outvec: STD_LOGIC_VECTOR(%ld downto 0);\n", options[OPT_2RAIL] ? errorsCnt-1 : circ->POs.size()-1);
		else
			fprintf(outfile, "\tsignal c0_cmp_outvec, c1_cmp_outvec: STD_LOGIC_VECTOR(%ld downto 0);\n", options[OPT_2RAIL] ? 3*errorsCnt-1 : circ->POs.size()-1);
	}

	if(options[OPT_E_AGGREG]) {
		fprintf(outfile, "\tsignal sig_errorVec : STD_LOGIC_VECTOR(%d downto 0);\n", errorsCnt-1);
		if( options[OPT_ERROR_PO_SAMEW] )
			fprintf(outfile, "\tsignal errorDetected : STD_LOGIC;\n");

		if(options[OPT_2RAIL]) {
			fprintf(outfile, "\tsignal sig_errorVecPO : STD_LOGIC_VECTOR(%d downto 0);\n", errorsCnt-1);
			if( options[OPT_ERROR_PO_SAMEW] )
				fprintf(outfile, "\tsignal errorDetectedPO : STD_LOGIC;\n");
		}
	} else {
		if( options[OPT_ERROR_PO_SAMEW] ) {
			fprintf(outfile, "\tsignal sig_errorVec : STD_LOGIC_VECTOR(%d downto 0);\n", errorsCnt-1);
			if(options[OPT_2RAIL]) {
				fprintf(outfile, "\tsignal sig_errorVecPO : STD_LOGIC_VECTOR(%d downto 0);\n", errorsCnt-1);
			}
		}
	}
	
	fprintf(outfile, "\tcomponent %s is\n", circ->name.c_str());
	fprintf(outfile, "\t\tPort (\n");
	for(i=0; i<PIsNames.size(); i++)
		fprintf(outfile, "\t\t\t%s : in %s;\n", PIsNames[i].c_str(), PIsTypes[i].c_str());
	for(i=0; i<POsNames.size(); i++)
		fprintf(outfile, "\t\t\t%s : out %s%s", POsNames[i].c_str(), POsTypes[i].c_str(), (i == POsNames.size()-1) ? ");\n" : ";\n");
	fprintf(outfile, "\tend component;\n");
	
	//declares the two copies' outputs
	for(i=0; i<POsNames.size(); i++){
		fprintf(outfile, "\tsignal c0_%s :  %s;\n", POsNames[i].c_str(), POsTypes[i].c_str());
		fprintf(outfile, "\tsignal c1_%s :  %s;\n", POsNames[i].c_str(), POsTypes[i].c_str());
	}
	
	fprintf(outfile, "begin\n"); /****************************************************/
	//instanstiate the two copies
	for(i=0; i<2; i++){
		fprintf(outfile, "\tcpy%d : %s\n", i, circ->name.c_str());
		fprintf(outfile, "\t\tport map(\n");
		if(options[OPT_DUPLICATE_PI] && i == 1) {
			int currentPIIdx = 0;
			for(j=0; j<PIsNames.size(); j++){
				if(PIsVecSize[j] > 1)
					fprintf(outfile, "\t\t\t%s => inputs_copy(%d downto %d),\n", PIsNames[j].c_str(), currentPIIdx + (PIsVecSize[j]-1), currentPIIdx);
				else
					fprintf(outfile, "\t\t\t%s => inputs_copy(%d),\n", PIsNames[j].c_str(), currentPIIdx);
				currentPIIdx += PIsVecSize[j];
			}
		} else {
			for(j=0; j<PIsNames.size(); j++)
				fprintf(outfile, "\t\t\t%s => %s,\n", PIsNames[j].c_str(), PIsNames[j].c_str());
		}
		for(j=0; j<POsNames.size(); j++)
			fprintf(outfile, "\t\t\t%s => c%d_%s%s", POsNames[j].c_str(), i, POsNames[j].c_str(), (j == POsNames.size()-1) ? "\n" : ",\n");
		fprintf(outfile, "\t);\n");
	}
	
	//Shorts instantiation************************************************************
	//connects one of the copies outputs to the top output
	for(i=0; i<circ->POs.size(); i++)
		fprintf(outfile, "\t%s <= c0_%s;\n", circ->POs[i]->name.c_str(), circ->POs[i]->name.c_str());
	
	//Checker LUTs
	if(options[OPT_NO_CMP_MODULE]){
		for(k=0; k<2; k++){
			for(i=0; i<circ->POs.size()-2; i+=3){
				fprintf(outfile, "\tcheckerLUT%d_%d : LUT6\n", k, i/3);
				fprintf(outfile, "\t\tgeneric map (\n");
				fprintf(outfile, "\t\t\tINIT => X\"6FF6FFFFFFFF6FF6\"\n");
				fprintf(outfile, "\t\t)\n");
				fprintf(outfile, "\t\tport map (\n");
				for(j=0; j<3; j++){
					fprintf(outfile, "\t\t\tI%d => c0_%s,\n", 2*j, circ->POs[i+j]->name.c_str());
					fprintf(outfile, "\t\t\tI%d => c1_%s,\n", 2*j+1, circ->POs[i+j]->name.c_str());
				}
				fprintf(outfile, "\t\t\tO => errorVec%d(%d)\n", k, i/3);
				fprintf(outfile, "\t\t);\n");	
			}
	
			if(circ->POs.size() % 3 == 1){
				fprintf(outfile, "\tcheckerLUT%d_%d : LUT2\n", k, errorsCnt-1);
				fprintf(outfile, "\t\tgeneric map (\n");
				fprintf(outfile, "\t\t\tINIT => X\"6\"\n");
				fprintf(outfile, "\t\t)\n");
				fprintf(outfile, "\t\tport map (\n");
				fprintf(outfile, "\t\t\tI0 => c0_%s,\n", circ->POs[circ->POs.size()-1]->name.c_str());
				fprintf(outfile, "\t\t\tI1 => c1_%s,\n", circ->POs[circ->POs.size()-1]->name.c_str());
				fprintf(outfile, "\t\t\tO => errorVec%d(%d)\n", k, errorsCnt-1);
				fprintf(outfile, "\t\t);\n");
			}
	
			if(circ->POs.size() % 3 == 2){
				fprintf(outfile, "\tcheckerLUT%d_%d : LUT4\n", k, errorsCnt-1);
				fprintf(outfile, "\t\tgeneric map (\n");
				fprintf(outfile, "\t\t\tINIT => X\"6FF6\"\n");
				fprintf(outfile, "\t\t)\n");
				fprintf(outfile, "\t\tport map (\n");
				fprintf(outfile, "\t\t\tI0 => c0_%s,\n", circ->POs[circ->POs.size()-2]->name.c_str());
				fprintf(outfile, "\t\t\tI1 => c1_%s,\n", circ->POs[circ->POs.size()-2]->name.c_str());
				fprintf(outfile, "\t\t\tI2 => c0_%s,\n", circ->POs[circ->POs.size()-1]->name.c_str());
				fprintf(outfile, "\t\t\tI3 => c1_%s,\n", circ->POs[circ->POs.size()-1]->name.c_str());
				fprintf(outfile, "\t\t\tO => errorVec%d(%d)\n", k, errorsCnt-1);
				fprintf(outfile, "\t\t);\n");
			}
			if(!options[OPT_2RAIL])
				break;
		}
	} else {
		for(i=0; i < circ->POs.size(); i++){
			fprintf(outfile, "\tc0_cmp_outvec(%d) <= c0_%s;\n", i, circ->POs[i]->name.c_str());
			fprintf(outfile, "\tc1_cmp_outvec(%d) <= c1_%s;\n", i, circ->POs[i]->name.c_str());
		}
		if(options[OPT_2RAIL]) {
			if(options[OPT_ERROR_PO_SAMEW]) {
				fprintf(outfile, "\tpo_checker : comparator\n");
				fprintf(outfile, "\t\tport map (\n");
				fprintf(outfile, "\t\t\tinVecA(%d downto 0) => c0_cmp_outvec,\n", errorsCnt-1);
				fprintf(outfile, "\t\t\tinVecA(%d downto %d) => c0_cmp_outvec,\n", errorsCnt*2-1, errorsCnt);
				fprintf(outfile, "\t\t\tinVecB(%d downto 0) => c1_cmp_outvec,\n", errorsCnt-1);
				fprintf(outfile, "\t\t\tinVecB(%d downto %d) => c1_cmp_outvec,\n", errorsCnt*2-1, errorsCnt);
				fprintf(outfile, "\t\t\terrors(%d downto 0) => sig_errorVec,\n", errorsCnt-1);
				fprintf(outfile, "\t\t\terrors(%d downto %d) => sig_errorVecPO\n", 2*errorsCnt-1, errorsCnt);
			} else {
				for(i=circ->POs.size(); i < errorsCnt*3; i++){
					fprintf(outfile, "\tc0_cmp_outvec(%d) <= '0';\n", i);
					fprintf(outfile, "\tc1_cmp_outvec(%d) <= '0';\n", i);
				}
				fprintf(outfile, "\tpo_checker : comparator\n");
				fprintf(outfile, "\t\tport map (\n");
				fprintf(outfile, "\t\t\tinVecA(%d downto 0) => c0_cmp_outvec,\n", errorsCnt*3-1);
				fprintf(outfile, "\t\t\tinVecA(%d downto %d) => c0_cmp_outvec,\n", errorsCnt*6-1, errorsCnt*3);
				fprintf(outfile, "\t\t\tinVecB(%d downto 0) => c1_cmp_outvec,\n", errorsCnt*3-1);
				fprintf(outfile, "\t\t\tinVecB(%d downto %d) => c1_cmp_outvec,\n", errorsCnt*6-1, errorsCnt*3);
				fprintf(outfile, "\t\t\terrors(%d downto 0) => sig_errorVec,\n", errorsCnt-1);
				fprintf(outfile, "\t\t\terrors(%d downto %d) => sig_errorVecPO\n", 2*errorsCnt-1, errorsCnt);
			}
			fprintf(outfile, "\t\t);\n");

			if( options[OPT_E_AGGREG] && options[OPT_ERROR_PO_SAMEW] ){
				fprintf(outfile, "\n\terrorVec(%d downto 1) <= sig_errorVec;\n", errorsCnt);
				fprintf(outfile, "\terrorVec(0) <= errorDetected;\n");
				fprintf(outfile, "\terrorVecPO(%d downto 1) <= sig_errorVecPO;\n", errorsCnt);
				fprintf(outfile, "\terrorVecPO(0) <= errorDetectedPO;\n\n");
			}
		} else {
			if(options[OPT_ERROR_PO_SAMEW]) {
				fprintf(stderr, "%s %d : DON'T KNOW WHAT TO DO!!!!\n", __FILE__, __LINE__);
				return;
			} else {
				fprintf(outfile, "\tpo_checker : comparator\n");
				fprintf(outfile, "\t\tport map (\n");
				fprintf(outfile, "\t\t\tinVecA => c0_cmp_outvec,\n");
				fprintf(outfile, "\t\t\tinVecB => c1_cmp_outvec,\n");
				fprintf(outfile, "\t\t\terrors => errorVec\n");
				fprintf(outfile, "\t\t);\n");
			}
		}
	}
	//Error aggregation instantiation************************************************************
	if(options[OPT_E_AGGREG]){
		if(errorsCnt > 1){
			fprintf(outfile, "\terror_aggreg : multiple_input_or\n");
			fprintf(outfile, "\t\tport map (\n");
			fprintf(outfile, "\t\t\tinput_vec => sig_errorVec,\n");
			fprintf(outfile, "\t\t\toutput => errorDetected\n");
			fprintf(outfile, "\t);\n");
			if(options[OPT_2RAIL]){
				fprintf(outfile, "\terror_aggreg2 : multiple_input_or\n");
				fprintf(outfile, "\t\tport map (\n");
				fprintf(outfile, "\t\t\tinput_vec => sig_errorVecPO,\n");
				fprintf(outfile, "\t\t\toutput => errorDetectedPO\n");
				fprintf(outfile, "\t);\n");
			}
		} else {
			fprintf(outfile, "\terrorDetected <= errorVec(0);\n");
			if(options[OPT_2RAIL])
				fprintf(outfile, "\terrorDetectedPO <= errorVecPO(0);\n");
		}
	}
	
	fprintf(outfile, "end Structure;\n");
}
